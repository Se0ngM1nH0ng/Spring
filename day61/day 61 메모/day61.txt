서버가 동작 한다는것은, 톰캣이 동작했다는 것이고, 톰캣이 동작 했다는것은 서블릿 컨테이너가 동작 했다는 것이다.
	즉, web.xml 이 로딩 된다.
	Xxx 컨테이너 == Xxx.xml
	.xml (설정 파일)이 있어야, 서블릿 컨테이너가 동작 된다.
	
	<servlet> == <bean> == 	new
	@WebServlet				@Component

----------------------------


	//	[ 참고 ]
	//	반환타입을 String 이라고 했었는데, 이게 뭘까 ?
	//	이 페이지의 확장자가 뭔지, 어떻게 갈지, 어디로 갈지 "주체"를 알 수 있다.
	
	//	ViewResolver 라고 한다.
	//	: Controller 류의 객체가, .handleRequest() 의 수행 결과로,
	//	String을 반환 했을 때,
	//	'어떻게 갈지' 와 '어디로 갈지' 를 판단해서 처리 하는 "주체" 이다.
	
	//	Spring 에서는 XxxResolver 들을 많이 구현해 두었다.
	//	>> 특정 역할을 자동으로 수행 해주는 기능을 가진 아이.

-----------------------------

//	ViewResolver 는 자신의 멤버변수를 setter를 통해서 받는다.
	//	즉, ViewResolver는 setter의 인자로,
	//	"경로" 를 받으면, '어떻게 갈지' 와 '어디로 갈지' 를 앞 / 뒤 로 붙혀서 반환 한다.
	//	이 ViewResolver는 , DispatcherServlet 에서 사용 한다.
	//	즉, DispatcherServlet의 멤버로 사용 될테니까, 의존 주입을 해야 한다.

------------------------------

//	handlerMapping를 의존 주입 하기 위해서, init() 메서드를 작성 한다.
	//	viewResolver를 의존 주입 하기 위해서, init() 메서드를 작성 한다.
	
	//	기존, 의존 주입을 하는 방법으로는, 생성자 주입, setter 주입, @ (어노테이션) 3가지 였는데,
	//	특이하게 DispatcherServlet 서블릿의 의존관계로 놓인 멤버의 의존 주입은,
	//	init() 메서드를 사용 해서 의존 주입을 한다.

------------------------------

흐름

사용자가 .do 요청을 보내

그러면 .xml에서 매핑 해서

DispatcherServlet 여기로 와

그리고 그 요청을 doAction 메서드의 인자로 들어와

command를 뽑아내 (substring 사용해서)

팩토리 패턴으로 되어있는
handlerMapping의 get 메서드에 command 를 인자로 넣기

command 값 즉, 사용자 요청값에 맞는
객체를 반환 (컨트롤러 타입의 객체)

암튼 흐름은 이렇다.

★ 왜 이렇게 코딩을 하는것일까? ★ 

상대적으로 무거운 파일인 DispatcherServlet 은
Not POJO 이다. 즉, 유일한 Not POJO 인데,

이렇게 코딩을 하면, 코드를 변경 하지 않게 되서,

재 컴파일을 하지 않게 된다는 장점을 가지게 된다 !!

------------------------------

오늘의 핵심 내용 !

[ Spring MVC로 변경 하기 ]

1) web.xml 에서 내가 만든 클래스를
Spring이 제공하는 클래스로 변경 !

★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★

로그 분석 하기 >>

WebApplicationContext
XxxApplicationContext == 컨테이너를 구동 하겠다는 의미.
무조건 .xml 이 필요 하다 !

DispatcherServlet-servlet 이라는 이름의 resource가 필요 하다는 의미.
[/WEB-INF/DispatcherServlet-servlet.xml]

>> (/WEB-INF 하위에 만들어 ~)

현재 위의 파일이 없기 때문에,
DS를 초기화 (DI (의존 주입) 할 때 사용 되는) .init()이 호출 될 수 없어서 발생 하는 에러 이다.

(멤버변수 초기화 할 때 사용 되는 메서드 >> .init() 메서드.

로그 분석을 왜 해야 할까 ?

새로운 프레임워크를 만났을 때, 항상 보게 되는 에러 로그 일텐데,
해당하는 로그가 어떤 의미를 가지는지를,
파악 할 수 있어야 에러 해결이 가능 하기 때문에..

★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★

[참고]

WebApplicationContext는

AbstractApplicationContext 추상클래스를
상속 받은 대표적인 웹 관련 클래스 이다.
(웹을 구동 하겠다는 의미를 가진 클래스)

1.5) web.xml에 스프링이 제공하는 필터 클래스를 추가.

2) 스프링이 제공하는 클래스로 Controller 변경.
반환이 String 이였는데,
ModelAndView로 변경 !

3) 사용자의 Xxx.do 요청에 대해서 수행할 Controller 클래스 까지 구현 완료 된 상태.

그러면,

HandlerMapping이 사용자의 요청에 대한 Controller 자료형 객체 반환을 수행 하므로,
HM을 생성 해야 한다.
HM은 DS에서 DI되는 클래스 이다.

Spring 실습 기준으로,
HandlerMapping를 DI 할때는, setter로 의존 주입을 해야 한다 !

따라서, DispatcherServlet-servlet.xml 에서 설정 하면 된다 !

HM이 일단, POJO 니까, 당연히 POJO.xml 에서 ~~

DispatcherServlet-servlet.xml 가 POJO.xml 이다.

(web.xml은 Not POJO.xml 이다)

--------------------------------------------------
메모 .. 다시 정리..

사용자가 .do 요청을 보내면

web.xml 에서 반응? 하는데

web.xml 먼저 반응하고 나서 ,DS.xml 을 ..

--------------------------------------------------

.jsp 파일 내부의 코드가 DB를 치고 와야지만,
데이터를 받을 수 있는 경우에는,
(예를들어, %{bdatas} 라던지 ..)
WEB-INF 폴더 하위에서 관리 한다.
이렇게 하는 이유는, 사용자가 직접적으로
접근 하는것을 막기 위함 이다.
즉, 에러를 방지 하기 위해 "하이딩" 하는 개념 이다.
이렇게, 관리하는 .jsp 파일은
오직, ViewResolver 를 통해서만 접근 할 수 있다 !

--------------------------------------------------

실제 스프링은 xml 기능 설정 파일 내부에 코드가 길지 않고,
@ 어노테이션을 훨씬 더 많이 사용 한다.
>> 가독성 측면에서 훨씬 유리 하기 때문.

--------------------------------------------------

@Component

1) @Repository >> M, DAO.
2) @Service >> C, Service 레이어 에서 활용 된다.
3) @Controller >> C, implements Controller를 대신 한다.
(Controller 인터페이스를 구현 하는것을 대신 한다)

여기 다시 작성 하기.. 핸들러매핑을 ???

1. 현재 @Controller 를 사용 하고 있어서,
메서드와 메서드 시그니쳐 강제성이 부여 되어 있지 않는다.

2. 특정 요청에 대해 Controller 객체를 찾아가는게 아니라,
메서드를 찾아간다.

3. 1개의 클래스 파일에 딱 1개의 기능을 한다.
즉, 응집도가 낮다고 할 수 있다.

1, 2, 3 에 기존 상황에서,
개발자는 아래와 같은 생각을 하게 된다 !!

>>
하나의 Controller 클래스에, 두개 이상의 메서드가 있어도 되나요 ?
네 !!!
왜 ? 메서드 + 메서드 시그니쳐 강제성이 더이상 부여 되지 않기 때문에 !

인자 개수도 막 내맘대로 할 수 있으니까 ~

그래서, 유사한 코드 또는 관련된 애들끼리 한 클래스에,
몰아 넣어서 응집도를 높히고 유지보수를 용이 하게 할 수 있다.

Command 객체를 사용 할 수 있다 !

Command 객체란 ???

★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★

IoC : 제어의 역행 (내가 객체를 인스턴스화 하지 않고, 스프링 컨테이너가 대신 해준다)

[ Command 객체 ] 

:
컨테이너는 객체를 생성 및 관리 한다. (디폴트로 객체를 인스턴스화 해준다)
즉, 해당 객체가 언제, 어떤 메서드를 호출 해야 하는지를 관리 한다.

ex) DS가 초기화 될때, init() 메서드를 호출 한다.
ex) DS가 .do 요청을 받았을 때, doGet() or doPost() 메서드를 호출 한다.



:
요청을 받았을 때, new VO() 는 당연히 하는거고 (객체 생성)
뿐만아니라, setter()을 호출 할 수 없을까 ? 라는 의문이 들었고 !
실제로 그 기능을 제공해준다 !

>> Command 객체

request 로부터 값을 추출해서 setter() 처리 까지 전부 완료 해주는 객체.

★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★
인자로 BoardVO bVO를 적으면, BoardVO 자료형의 객체 생성은 물론이고, 해당 객체의 setter() 호출 까지 전부 다 해준다 !!!
원하는 자료형을 객체화 하고 싶다 ? == new 를 하고 싶다 ?
전부다 인자로 자료형과 참조변수명을 넣어 !!!
		
★ 이것을 Command 객체 라고 한다 ★

★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★

---------------------------------------------

@RequestMapping 어노테이션은, 기존의 HandlerMapping의 기능을 하는 어노테이션 이다.

@RequestMapping은 속성을 여러개 가질 수 있다.

@RequestMapping(value="insertBoard".do", method=RequestMethod.GET)

@RequestMapping(value="insertBoard".do", method=RequestMethod.POST)

분기 처리 가능하고, value 값을 같게 할 수 있다.

어떻게 ? method = POST 방식인지, GET 방식인지 !

@ 어노테이션 방식을 사용 하면,

WEB-INF 폴더에 숨길 수 없고 (하이딩)

대신에, GET or POST 식으로.. ?

이게 무슨 말??




